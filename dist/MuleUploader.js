!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.muleUploader=e():t.muleUploader=e()}(window,function(){return function(t){var e={};function o(s){if(e[s])return e[s].exports;var i=e[s]={i:s,l:!1,exports:{}};return t[s].call(i.exports,i,i.exports,o),i.l=!0,i.exports}return o.m=t,o.c=e,o.d=function(t,e,s){o.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},o.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},o.t=function(t,e){if(1&e&&(t=o(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(o.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)o.d(s,i,function(e){return t[e]}.bind(null,i));return s},o.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return o.d(e,"a",e),e},o.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},o.p="",o(o.s=0)}([function(t,e,o){"use strict";o.r(e),o.d(e,"GCSUpload",function(){return a});const s="session",i=32;console.debug=function(){};const n=(t,e={})=>new Promise((o,s)=>{let i=new XMLHttpRequest;i.open(e.method||"get",t);for(let t in e.headers||{})i.setRequestHeader(t,e.headers[t]);i.onload=(t=>o(t.target)),i.onerror=s,i.upload&&e.onProgressCallback&&(i.upload.onprogress=e.onProgressCallback),i.send(e.body)}),r=t=>new Promise(e=>setTimeout(e,t));class a{constructor(t){if(console.log("muleUploader GCSUpload 2.0.0 "),this.options=Object.assign({authorizeSecurityMode:s,authorizeFetchMode:"cors",chunkSize:268435456,parallelUploads:1,parallelMinSize:268435456},t),!this.options.uploadAuthorizationURL)throw"an upload authorization URL is required";if(!this.options.composeAuthorizationURL)throw"a compose authorization URL is required"}loadFile(t){if(!t.name||!t.size)throw"not able to load file";this.file=t,console.debug("File loaded",{size:this.file.size})}async run(){if(!this.file)throw"file not loaded";if(this.options.authorizeSecurityMode!=s)throw"backend security mode not implemented";try{let t=new c(this.file,this.options);await t.run()}catch(t){throw`not able to upload, ${t}`}}}class h{constructor(t,e){if(this.chunk=t,this.options=Object.assign({onErrorRetryCount:0},e),!this.chunk.payload)throw"chunk must have a payload attribute";if(!this.chunk.contentType)throw"chunk must have a contentType attribute";if(!this.chunk.contentRange)throw"chunk must have a contentType attribute";if(!this.chunk.expectedReturnCode)throw"chunk must have a expectedReturnCode attribute";if(void 0===this.chunk.rangeStart)throw"chunk must have a rangeStart attribute";if(void 0===this.chunk.rangeEnd)throw"chunk must have a rangeEnd attribute"}async run(){let t=[];for(let e=0;e<=this.options.onErrorRetryCount;e++){try{let e=await n(this.options.uploadURI,{method:"PUT",body:this.chunk.payload,onProgressCallback:this.options.onProgressCallback,headers:{"Content-Type":this.chunk.contentType,"Content-Range":this.chunk.contentRange}});if(console.debug("got response",e),e.status!=this.chunk.expectedReturnCode)throw`error while pushing chunk: ${e.status} ${e.statusText}`;return e}catch(e){t.push(e)}console.debug("Truncated Exponential Backoff"),await r(1e3*Math.pow(2,e)+1e3*Math.random())}throw t}}class u{constructor(t,e){if(this.storageObject=t,this.options=Object.assign({chunkSize:5242880},e),!this.storageObject.fileName)throw"storageObject must have a fileName attribute";if(!this.storageObject.payload)throw"storageObject must have a payload attribute";console.debug("StorageObject chunk size is",this.options.chunkSize),this.chunksCount=Math.ceil(this.storageObject.payload.size/this.options.chunkSize),this.chunks=[...Array(this.chunksCount).keys()],this.chunksProgress=[...Array(this.chunksCount).values()]}_getNextChunk(){let t=this.chunks.shift();if(void 0===t)return;let e=t*this.options.chunkSize,o=Math.min(e+this.options.chunkSize,this.storageObject.payload.size),s=`bytes ${e}-${o-1}/${this.storageObject.payload.size}`;return{ID:t,payload:this.storageObject.payload.slice(e,o),contentType:"application/octet-stream",contentRange:s,rangeStart:e,rangeEnd:o,expectedReturnCode:t+1==this.chunksCount?200:308}}_onChunkProgress(t,e){e.loaded&&(this.chunksProgress[t]=e.loaded),this._onStorageObjectProgress()}_onStorageObjectProgress(){let t=0;for(let e of this.chunksProgress)t+=e||0;console.debug("_onStorageObjectProgress",t,this.storageObject.payload.size),this.options.onProgressCallback&&this.options.onProgressCallback(t,this.storageObject.payload.size)}async run(){this.session=await this._getAuthorization(),console.debug("StorageObject session received",this.session);try{let t;for(;void 0!==(t=this._getNextChunk());){console.debug("nextChunk",t);let e=new h(t,{uploadURI:this.session.uploadURI,onErrorRetryCount:2,onProgressCallback:this._onChunkProgress.bind(this,t.ID)});await e.run()}}catch(t){throw`not able to upload chunk, ${t}`}}async _getAuthorization(){console.debug("getting authorization for",this.storageObject);let t=new URLSearchParams;t.append("fileName",this.storageObject.fileName),t.append("fileSize",this.storageObject.payload.size);let e=new Request(this.options.uploadAuthorizationURL+"?"+t.toString(),{method:"GET",cache:"no-store"}),o=await fetch(e,{mode:this.options.authorizeFetchMode});if(o.status<200||o.status>299)throw`error while getting upload authorization: ${o.status} ${o.statusText}`;return o.json()}}class c{constructor(t,e){this.file=t,this.options=Object.assign({parallelUploads:1},e),console.debug("File upload settings",e),this.storageObjectsCount=Math.max(1,Math.min(i,Math.floor(this.file.size/this.options.parallelMinSize)));let o=Math.ceil(this.file.size/this.storageObjectsCount);this.storageObjects=[],this.storageObjectsProgress=[...Array(this.storageObjectsCount).values()];for(let t=0;t<this.storageObjectsCount;t++)this.storageObjects.push({ID:t,fileName:`${this.file.name}.${t}`,payload:this.file.slice(t*o,Math.min(o*(t+1),this.file.size))});this.objectsComposition=this.storageObjects.reduce((t,e)=>(t.push({name:e.fileName}),t),[]),console.debug("Storage objects computation",{objectsCount:this.storageObjectsCount,objectSize:o,objects:this.storageObjects,objectsComposition:this.objectsComposition}),this.speedMonitorStart=this.speedMonitorEnd=0}_getNextStorageObject(){return this.storageObjects.shift()}_onStorageObjectProgress(t,e,o){this.storageObjectsProgress[t]=e,this._onFileProgress()}_onFileProgress(){let t=Date.now(),e=0;for(let t of this.storageObjectsProgress)e+=t||0;let o=(t-this.speedMonitorStart)/1e3,s=8*this.file.size/o/1024/1024;console.debug("_onfileProgress",e,this.file.size,o,s),this.options.onProgressCallback&&this.options.onProgressCallback(e,this.file.size,o,s)}async run(){this.speedMonitorStart=Date.now();var t=[];for(let e=0;e<Math.min(this.options.parallelUploads,this.storageObjectsCount);e++)console.debug("Launching runner",e),t.push(this._runner());return await Promise.all(t),console.info("all running uploads successfully finished"),this._onFileProgress(),await this._composeStorageObjects()}async _runner(){let t;for(;void 0!==(t=this._getNextStorageObject());){let e=new u(t,Object.assign({},this.options,{onProgressCallback:this._onStorageObjectProgress.bind(this,t.ID)}));await e.run()}console.debug("Finishing runner")}async _composeStorageObjects(){console.debug("composing objects");let t=new URLSearchParams;t.append("fileName",this.file.name);let e=new Request(this.options.composeAuthorizationURL+"?"+t.toString(),{method:"POST",body:JSON.stringify(this.objectsComposition),cache:"no-store"}),o=await fetch(e,{mode:this.options.authorizeFetchMode});if(o.status<200||o.status>299)throw`error while getting compose authorization: ${o.status} ${o.statusText}`;return o.json()}}}])});